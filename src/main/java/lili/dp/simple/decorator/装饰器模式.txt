装饰模式的结构
	装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任。
	换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。
	装饰模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。

	在装饰模式中的角色有：

 1、抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。
 2、具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类。
 3、装饰(Decorator)角色：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。
 4、具体装饰(ConcreteDecorator)角色：负责给构件对象“贴上”附加的责任。

 OO原则：动态的将责任附加到对象上。想要扩展功能，装饰者提供有别于继承的另一种选择。
要点：
1、继承属于扩展形式之一，但不见得是达到弹性设计的最佳方案
2、在我们的设计中，应该允许行为可以被扩展，而不须修改现有的代码
3、组合和委托可用于在运行时动态地加上新的行为
4、除了继承，装饰器模式也可以让我们扩展行为
5、装饰器模式意味着一群装饰器类，这些类用来包装具体组件
6、装饰器类反应出被装饰的组件类型（实际上，他们具有相同的类型，都经过接口和继承实现）
7、装饰器可以在被装饰的行为前面或后面加上自己的行为，甚至将被装饰者的行为整个取代掉
	而达到特定的目的。
8、你可以有无数个装饰者包装一个组件
9、装饰者一般对组建的客户是透明的，除非客户程序依赖于组件的具体类型
10、装饰器会导致设计中出现许多的小对象，如果过度使用，会让程序变得很复杂