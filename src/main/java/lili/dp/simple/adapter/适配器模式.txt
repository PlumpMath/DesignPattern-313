TODO
http://blog.csdn.net/hguisu/article/details/7527842

 GoF书中提出的适配器(Adapter)模式更倾向于运用继承而不是组成。这在强类型语言中是有利的，
 因为适配器(Adapter)事实上是一个目标类的子类，因而能更好地与类中方法相结合。

 http://www.cnblogs.com/devinzhang/archive/2011/12/22/2298677.html
 类适配器：采用继承
 对象适配器：采用组合

 适配器模式的组成

•目标角色（Target）：— 定义Client使用的与特定领域相关的接口。
• 客户角色（Client）：与符合Target接口的对象协同。
• 被适配橘色（Adaptee)：定义一个已经存在并已经使用的接口，这个接口需要适配。
• 适配器角色（Adapte) ：适配器模式的核心。它将对被适配Adaptee角色已有的接口转换为目标角色Target匹配的接口。对Adaptee的接口与Target接口进行适配.

适配器模式与其它相关模式

桥梁模式(bridge模式)：桥梁模式与对象适配器类似，但是桥梁模式的出发点不同：桥梁模式目的是将接口部分和实现部分分离，
从而对它们可以较为容易也相对独立的加以改变。而对象适配器模式则意味着改变一个已有对象的接口

装饰器模式(decorator模式)：装饰模式增强了其他对象的功能而同时又不改变它的接口。因此装饰模式对应用的透明性比适配器更好。
结果是decorator模式支持递归组合，而纯粹使用适配器是不可能实现这一点的。

Facade（外观模式）：适配器模式的重点是改变一个单独类的API。Facade的目的是给由许多对象构成的整个子系统，
提供更为简洁的接口。而适配器模式就是封装一个单独类，适配器模式经常用在需要第三方API协同工作的场合，设法把你的代码与第三方库隔离开来。

适配器模式与外观模式都是对现相存系统的封装。但这两种模式的意图完全不同，前者使现存系统与正在设计的系统协同工
作而后者则为现存系统提供一个更为方便的访问接口。简单地说，适配器模式为事后设计，而外观模式则必须事前设计，
因为系统依靠于外观。总之，适配器模式没有引入新的接口，而外观模式则定义了一个全新的接口。

